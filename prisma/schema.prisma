// Prisma schema for LatamTCG MTG catalog and pricing

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}


model MtgCard {
  id                String   @id @default(cuid())
  scryfallId        String   @unique
  oracleId          String   @default("")
  name              String
  setCode           String
  collectorNumber   String
  rarity            String?
  finishes          String[]
  frameEffects      String[]
  promoTypes        String[]
  borderColor       String?
  fullArt           Boolean? @default(false)
  legalitiesJson    Json?
  priceUsd          Decimal? @db.Decimal(10, 2)
  priceUsdFoil      Decimal? @db.Decimal(10, 2)
  priceUsdEtched    Decimal? @db.Decimal(10, 2)
  priceEur          Decimal? @db.Decimal(10, 2)
  priceTix          Decimal? @db.Decimal(10, 2)
  priceUpdatedAt    DateTime?
  // filtering & debugging
  lang              String   @default("en")
  isPaper           Boolean  @default(false)
  setType           String?
  releasedAt        DateTime?
  scryfallUpdatedAt DateTime?
  updatedAt         DateTime @updatedAt
  createdAt         DateTime @default(now())

  // Optional relation to normalized Set table (backfilled), joined by setCode
  set               Set?  @relation(fields: [setCode], references: [set_code])

  @@index([oracleId])
  @@index([isPaper, lang])
  @@index([setCode])
  @@index([name])
}

model KvMeta {
  key       String  @id
  value     String
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())
}


/// Denormalized search suggestions across games. For MTG, one row per physical printing.
model SearchIndex {
  /// Use underlying printing id where available (MTG uses scryfallId)
  id               String   @id
  /// Oracle or group id to link to grouped view (MTG uses oracleId)
  groupId          String
  /// Game identifier, e.g., "mtg", "pokemon"
  game             String
  /// Display title (normalized name; may include variant in UI rendering)
  title            String
  /// Subtitle such as set code/name and collector number
  subtitle         String
  /// Free-form keywords blob for fuzzy/prefix search (normalized)
  keywordsText     String
  /// Human label for finish preference (Nonfoil/Foil/Etched)
  finishLabel      String?
  /// Variant label such as Borderless/Showcase/Extended Art/Retro/JP Alt Art/etc.
  variantLabel     String?
  /// Complete variant suffix formatted by formatCardVariant (e.g., "(Showcase) (Extended Art) (Foil)")
  variantSuffix    String?
  /// Language code
  lang             String
  /// Physical availability
  isPaper          Boolean  @default(true)
  /// Release date for tie-breakers
  releasedAt       DateTime?
  /// Composite score for ranking tweaks
  sortScore        Float?
  /// For MTG suggestions
  setCode          String
  setName          String?
  /// Precomputed sort key for deterministic A-Z sorting (normalized title + variantSuffix)
  nameSortKey      String?
  /// Precomputed sort key for deterministic Z-A sorting (same as nameSortKey, sorted DESC)
  nameSortKeyDesc  String?
  collectorNumber  String
  imageNormalUrl   String?
  name             String

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([game, lang, isPaper])
  @@index([releasedAt])
}

/// Normalized card set metadata (backfilled from MtgCard)
model Set {
  set_code     String    @id
  set_name     String
  released_at  DateTime?
  set_type     String?

  cards        MtgCard[]
}

model mtgcard_price_history {
  id          BigInt    @id @default(autoincrement())
  scryfall_id String    @db.Uuid
  finish      String
  price       Decimal   @db.Decimal(10, 2)
  price_at    DateTime  @db.Timestamptz
  price_day   DateTime? @db.Date
  source      String    @default("scryfall")

  @@unique([scryfall_id, finish, price_day], name: "uq_price_hist_per_day")
  @@index([scryfall_id, price_at(sort: Desc)], name: "ix_price_hist_card_time")
  @@map("mtgcard_price_history")
}


/// Basic User Management (v0)
/// Note: `User.id` mirrors Supabase Auth user id (UUID string).
model User {
  id         String    @id
  email      String?   @unique
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  profile    Profile?
  carts      Cart[]
  orders     Order[]
  addresses  Address[]
}

model Profile {
  id         String   @id @default(cuid())
  userId     String   @unique
  firstName  String?
  lastName   String?
  phone      String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user       User     @relation(fields: [userId], references: [id])
}

/// A shopping cart which may be anonymous (cookie `cart_token`) or attached to a user
model Cart {
  id          String      @id @default(cuid())
  userId      String?
  token       String?     @unique
  checkedOutAt DateTime?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  user        User?       @relation(fields: [userId], references: [id])
  items       CartItem[]

  @@index([userId])
  @@index([checkedOutAt])
}

model CartItem {
  id          String   @id @default(cuid())
  cartId      String
  printingId  String   // Scryfall UUID for MTG printing
  quantity    Int      @default(1)
  unitPrice   Decimal? @db.Decimal(10, 2)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  cart        Cart     @relation(fields: [cartId], references: [id], onDelete: Cascade)

  @@index([cartId])
  @@index([printingId])
}

model Order {
  id           String      @id @default(cuid())
  userId       String?
  email        String?
  totalAmount  Decimal?    @db.Decimal(10, 2)
  status       String      @default("created")
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  // Optional address snapshots (denormalized copy at time of order)
  shippingAddressId String?
  billingAddressId  String?

  user         User?       @relation(fields: [userId], references: [id])
  items        OrderItem[]
  shippingAddress Address? @relation("OrderShippingAddress", fields: [shippingAddressId], references: [id])
  billingAddress  Address? @relation("OrderBillingAddress", fields: [billingAddressId], references: [id])

  @@index([userId])
  @@index([createdAt])
}

model OrderItem {
  id          String   @id @default(cuid())
  orderId     String
  printingId  String   // Scryfall UUID for MTG printing
  quantity    Int      @default(1)
  unitPrice   Decimal? @db.Decimal(10, 2)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  order       Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@index([printingId])
}

model Address {
  id          String    @id @default(cuid())
  userId      String
  label       String?
  fullName    String?
  phone       String?
  line1       String
  line2       String?
  city        String
  state       String?
  postalCode  String?
  country     String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  user        User      @relation(fields: [userId], references: [id])
  // Backrefs for optional order relations
  shippingOrders Order[] @relation("OrderShippingAddress")
  billingOrders  Order[] @relation("OrderBillingAddress")

  @@index([userId])
}

